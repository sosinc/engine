(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{75:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var o=n(2),a=n(6),r=(n(0),n(78)),i={id:"state",title:"Use the State Luke!",sidebar_label:"State"},s={unversionedId:"quick-start-tutorial/state",id:"quick-start-tutorial/state",isDocsHomePage:!1,title:"Use the State Luke!",description:"Engine, like Redux, recommends keeping a single source of truth for our",source:"@site/docs/quick-start-tutorial/state.md",permalink:"/engine/docs/quick-start-tutorial/state",editUrl:"https://github.com/code11/engine/edit/master/docs/docs/quick-start-tutorial/state.md",sidebar_label:"State",sidebar:"docs",previous:{title:"Static UI",permalink:"/engine/docs/quick-start-tutorial/static-ui"},next:{title:"Recommended Architecture",permalink:"/engine/docs/quick-start-tutorial/mature-architecture"}},c=[{value:"Using state in components",id:"using-state-in-components",children:[]},{value:"Updating state from components",id:"updating-state-from-components",children:[]},{value:"Introducing new state",id:"introducing-new-state",children:[]}],l={rightToc:c};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Engine, like Redux, recommends keeping a single source of truth for our\napplication's state. Let's provide some initial todos for our app. In\n",Object(r.b)("inlineCode",{parentName:"p"},"src/index.tsx")),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),"const engine = new Engine({\n+ state: {\n+   initial: {\n+     todos: [\n+       { title: 'Add initial state to engine', isDone: false },\n+       { title: 'Use initial state in components', isDone: false }\n+     ]\n+   }\n+ },\n  view: {\n    element: <App />,\n    root: \"#root\"\n  }\n});\n")),Object(r.b)("p",null,"This is equivalent to creating a store in Redux, and initializing with intial\nstate. We can read more about creating the ",Object(r.b)("inlineCode",{parentName:"p"},"Engine")," instance in API docs for\n",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/api/engine"}),"Engine"),". Now that we have some todo items in our state, it's time\nto show them in our component."),Object(r.b)("h2",{id:"using-state-in-components"},"Using state in components"),Object(r.b)("p",null,"Wanna see a magic trick? Add these 3 lines to our ",Object(r.b)("inlineCode",{parentName:"p"},"src/App.tsx"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'import React from "react";\nimport "todomvc-app-css/index.css";\n+ import { view, Observe } from "@c11/engine.macro";\n+\n+ const App: view = ({ todos = Observe.todos }) => {\n+   console.warn("TODOS", todos);\n')),Object(r.b)("p",null,"We can see todos from our state printed in console! This is all the selectors we\nhave to write. Engine does its magic with babel-macros behind the scenes, and\nallow us to observe any part of our state with just few characters."),Object(r.b)("p",null,"Time to put these todos in jsx. In ",Object(r.b)("inlineCode",{parentName:"p"},"src/App.tsx"),", let's extract the ",Object(r.b)("inlineCode",{parentName:"p"},"<Todo>"),"\ncomponent out of ",Object(r.b)("inlineCode",{parentName:"p"},"<App>")," so that we can easily do ",Object(r.b)("inlineCode",{parentName:"p"},"todos.map(Todo)"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),'const Todo: React.FC<{ title: string }> = ({ title }) => (\n  <li>\n    <div className="view">\n      <input className="toggle" type="checkbox" />\n      <label>{title}</label>\n      <button className="destroy" />\n    </div>\n    <input className="edit" value={title} />\n  </li>\n);\n')),Object(r.b)("p",null,"Now we can update our ",Object(r.b)("inlineCode",{parentName:"p"},"App")," component with:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'        <section className="main">\n          <input id="toggle-all" className="toggle-all" type="checkbox" />\n          <label htmlFor="toggle-all">Mark all as complete</label>\n\n          <ul className="todo-list">\n+            {todos.map(Todo)}\n          </ul>\n        </section>\n')),Object(r.b)("h2",{id:"updating-state-from-components"},"Updating state from components"),Object(r.b)("p",null,"Rendering our state in components is one piece of the puzzle, another piece is\nmanipulating state from components. We'll now make the big todos ",Object(r.b)("inlineCode",{parentName:"p"},"<input>")," work,\nso that it can add new todos to our state. We want to add a todo whenever user\npresses ",Object(r.b)("inlineCode",{parentName:"p"},"Enter")," key, so we'll add a ",Object(r.b)("inlineCode",{parentName:"p"},"onKeyDown")," event:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'const App: view = ({ todos = Observe.todos }) => {\n+  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {\n+    console.warn(\'Keypress\', e);\n+  };\n   ...\n        <input\n          className="new-todo"\n          placeholder="What needs to be done?"\n          autoFocus={true}\n+         onKeyDown={handleKeyDown}\n        />\n')),Object(r.b)("p",null,"In a vanilla react app, we could simply use a ",Object(r.b)("inlineCode",{parentName:"p"},"setState")," call to add the new\nTodo. But if we want to keep a single-source-of-truth global state, we have to\ndeal with a bunch of boilerplate to achieve the simple thing. That could either\nbe the whole dance between actions, reducers and selectors of Redux, or passing\nthe callback props down a staircase of components in vanilla react."),Object(r.b)("p",null,"To achieve the same with Engine, we need access to an ",Object(r.b)("inlineCode",{parentName:"p"},"Update")," object for\n",Object(r.b)("inlineCode",{parentName:"p"},"state.todos"),". Just like ",Object(r.b)("inlineCode",{parentName:"p"},"Observe.todos")," gives us a reference to live ",Object(r.b)("inlineCode",{parentName:"p"},"todos"),"\narray in our state, we have ",Object(r.b)("inlineCode",{parentName:"p"},"Update.todos")," to give us an update object:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'- import { view, Observe } from "@c11/engine.macro";\n+ import { view, Observe, Update } from "@c11/engine.macro";\n...\n\n  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {\n+    if (e.key === "Enter") {\n+      const newTodos = [\n+        ...todos,\n+        { isDone: false, title: e.currentTarget.value }\n+      ];\n+\n+      updateTodos.set(newTodos);\n    }\n  };\n')),Object(r.b)("p",null,"If the key user has pressed is the ",Object(r.b)("inlineCode",{parentName:"p"},"Enter")," key, we compute the next set of\ntodos, and ",Object(r.b)("inlineCode",{parentName:"p"},"Update.todos")," allow us to replace existing todos in our state with\nthis new array. It's as easy as using vanilla React's ",Object(r.b)("inlineCode",{parentName:"p"},"setState"),", but we get to\nkeep our global state outside of components."),Object(r.b)("p",null,"But do it really solve the problem of passing callback props down multiple\nlevels of components? As a matter of fact, it do. ",Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"Update")," and ",Object(r.b)("inlineCode",{parentName:"strong"},"Observe")," can\nbe used at any level in our component tree"),". To demonstrate this, let's extract\nour ",Object(r.b)("inlineCode",{parentName:"p"},"<input>")," out to its own component ",Object(r.b)("inlineCode",{parentName:"p"},"TodoForm"),". In ",Object(r.b)("inlineCode",{parentName:"p"},"src/App.tsx"),", let's add:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),'const TodoForm: view = ({\n  todos = Observe.todos,\n  updateTodos = Update.todos\n}) => {\n  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === "Enter") {\n      const newTodos = [\n        ...todos,\n        { isDone: false, title: e.currentTarget.value }\n      ];\n\n      updateTodos.set(newTodos);\n    }\n  };\n\n  return (\n    <input\n      className="new-todo"\n      placeholder="What needs to be done?"\n      autoFocus={true}\n      onKeyDown={handleKeyDown}\n    />\n  );\n};\n')),Object(r.b)("p",null,"Now we can update our ",Object(r.b)("inlineCode",{parentName:"p"},"App")," component to use this component instead:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'- const App: view = ({ todos = Observe.todos, updateTodos = Update.todos }) => {\n+ const App: view = ({ todos = Observe.todos }) => {\n-   const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {\n-     if (e.key === "Enter") {\n-       const newTodos = [\n-         ...todos,\n-         { isDone: false, title: e.currentTarget.value }\n-       ];\n-\n-       updateTodos.set(newTodos);\n-     }\n-   };\n-\n  return (\n    ...\n-        <input\n-          className="new-todo"\n-          placeholder="What needs to be done?"\n-          autoFocus={true}\n-          onKeyDown={handleKeyDown}\n-        />\n+        <TodoForm />\n')),Object(r.b)("h2",{id:"introducing-new-state"},"Introducing new state"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"Observe.<key>")," and ",Object(r.b)("inlineCode",{parentName:"p"},"Update.<key>")," can do a lot more than that. It is possible\nto introduce completely new state to our global store. For instance, let's\nconvert our ",Object(r.b)("inlineCode",{parentName:"p"},"TodoForm")," into a ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://reactjs.org/docs/forms.html#controlled-components"}),"controlled React\ncomponent")," so that we\ncan clear the input when user presses ",Object(r.b)("inlineCode",{parentName:"p"},"Enter")," or ",Object(r.b)("inlineCode",{parentName:"p"},"Escape"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'const TodoForm: view = ({\n  todos = Observe.todos,\n  updateTodos = Update.todos,\n+  newTodoTitle = Observe.newTodoTitle,\n+  updateNewTodoTitle = Update.newTodoTitle\n}) => {\n+  const handleOnChange = (e: ChangeEvent<HTMLInputElement>) => {\n+    updateNewTodoTitle.set(e.currentTarget.value);\n+  };\n\n  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === "Enter") {\n      ...\n+     updateNewTodoTitle.set("");\n    }\n+\n+   if (e.key === "Escape") {\n+     updateNewTodoTitle.set("");\n+   }\n  };\n\n  return (\n    <input\n       ...\n+      onChange={handleOnChange}\n+      value={newTodoTitle || ""}\n')),Object(r.b)("p",null,"We added observer for ",Object(r.b)("inlineCode",{parentName:"p"},"state.newTodoTitle")," without initially declaring it in our\nstate we passed to ",Object(r.b)("inlineCode",{parentName:"p"},"Engine")," in ",Object(r.b)("inlineCode",{parentName:"p"},"src/index.tsx"),". We also added\n",Object(r.b)("inlineCode",{parentName:"p"},"Update.newTodoTitle"),", which we then use on the todo ",Object(r.b)("inlineCode",{parentName:"p"},"<input>"),"'s ",Object(r.b)("inlineCode",{parentName:"p"},"onChange"),"."),Object(r.b)("p",null,"Let's get rid of the todos from our initial state, and move on to the next\nstep."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'const engine = new Engine({\n  state: {\n    initial: {\n      todos: [\n-       { title: "Add initial state to engine", isDone: false },\n-       { title: "Use initial state in components", isDone: false }\n      ]\n    }\n  },\n')))}p.isMDXComponent=!0},78:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var o=n(0),a=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),p=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=p(n),u=o,m=d["".concat(i,".").concat(u)]||d[u]||b[u]||r;return n?a.a.createElement(m,s(s({ref:t},l),{},{components:n})):a.a.createElement(m,s({ref:t},l))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);