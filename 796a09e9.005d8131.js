(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{77:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return d})),n.d(t,"default",(function(){return c}));var o=n(2),a=n(6),i=(n(0),n(99)),r={id:"state-as-communication-channel",title:"State as Communication Channel",sidebar_label:"State as Communication Channel"},s={unversionedId:"tutorials/react/state-as-communication-channel",id:"tutorials/react/state-as-communication-channel",isDocsHomePage:!1,title:"State as Communication Channel",description:"It's time to make it possible to add new TodoItems to the state. To start off,",source:"@site/docs/tutorials/react/state-as-communication-channel.md",permalink:"/engine/docs/tutorials/react/state-as-communication-channel",editUrl:"https://github.com/code11/engine/edit/master/docs/docs/tutorials/react/state-as-communication-channel.md",sidebar_label:"State as Communication Channel",sidebar:"docs",previous:{title:"Introducing Producers",permalink:"/engine/docs/tutorials/react/introducing-producers"},next:{title:"Wrapping Up",permalink:"/engine/docs/tutorials/react/wrapping-up"}},d=[],l={rightToc:d};function c(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(o.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"It's time to make it possible to add new ",Object(i.b)("inlineCode",{parentName:"p"},"TodoItem"),"s to the state. To start off,\nextract ",Object(i.b)("inlineCode",{parentName:"p"},"TodoForm")," view out of ",Object(i.b)("inlineCode",{parentName:"p"},"src/App.tsx"),". Create a new file\n",Object(i.b)("inlineCode",{parentName:"p"},"src/TodoForm.tsx")," with following contents:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),'import React from "react";\n\nconst TodoForm = () => (\n  <input\n    className="new-todo"\n    placeholder="What needs to be done?"\n    autoFocus={true}\n  />\n);\n\nexport default TodoForm;\n')),Object(i.b)("p",null,"Update ",Object(i.b)("inlineCode",{parentName:"p"},"src/App.tsx")," accordingly:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'+ import TodoForm from "./TodoForm";\n...\n-    <input\n-      className="new-todo"\n-      placeholder="What needs to be done?"\n-      autoFocus={true}\n-    />\n+    <TodoForm />\n')),Object(i.b)("p",null,"Since global-state is the only kind of state recommended in Engine, a state\nvariable should be kept for what user is typing in our ",Object(i.b)("inlineCode",{parentName:"p"},"TodoForm")," input. Update\n",Object(i.b)("inlineCode",{parentName:"p"},"src/TodoForm.tsx")," to make its content be:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),'import React from "react";\nimport { view, Observe, Update } from "@c11/engine.macro";\n\nconst TodoForm: view = ({\n  updateNewTodoTitle = Update.newTodo.title,\n  newTodoTitle = Observe.newTodo.title\n}) => (\n    <input\n      className="new-todo"\n      placeholder="What needs to be done?"\n      autoFocus={true}\n      value={newTodoTitle || ""}\n      onChange={e => updateNewTodoTitle.set(e.currentTarget.value)}\n    />\n  );\n\nexport default TodoForm;\n')),Object(i.b)("p",null,"Above snippet:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Labeled ",Object(i.b)("inlineCode",{parentName:"li"},"TodoForm")," as ",Object(i.b)("inlineCode",{parentName:"li"},"view"),", so that it can use ",Object(i.b)("a",Object(o.a)({parentName:"li"},{href:"/docs/api/observe"}),"Observe"),"\nand ",Object(i.b)("a",Object(o.a)({parentName:"li"},{href:"/docs/api/update"}),"Update")," in its header"),Object(i.b)("li",{parentName:"ol"},"Introduced a new state path ",Object(i.b)("inlineCode",{parentName:"li"},".newTodo.title")),Object(i.b)("li",{parentName:"ol"},"Update ",Object(i.b)("inlineCode",{parentName:"li"},"newTodo.title")," whenever user enters something in the ",Object(i.b)("inlineCode",{parentName:"li"},"<input>"))),Object(i.b)("p",null,"A new todo should be added to the ",Object(i.b)("inlineCode",{parentName:"p"},"todosById")," object whenever user presses\n",Object(i.b)("inlineCode",{parentName:"p"},"Enter")," key in the input. It is possible to create an event handler in the view\nitself which does this work, but Engine recommends to not do it from the ",Object(i.b)("inlineCode",{parentName:"p"},"view"),".\nOnly logic that should go into a view is converting event payloads into value\nthey contain, and store them at some path in state. All the business logic\nbelongs in ",Object(i.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/api/producer"}),"producer"),"s."),Object(i.b)("p",null,"Next steps are to:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Add event listener for ",Object(i.b)("inlineCode",{parentName:"li"},"onKeyDown")," in the input"),Object(i.b)("li",{parentName:"ol"},"Convert the pressed key to the intent TodoForm want to express, and store it\nin the state"),Object(i.b)("li",{parentName:"ol"},"Create producers for committing and discarding the new todo")),Object(i.b)("p",null,"In ",Object(i.b)("inlineCode",{parentName:"p"},"src/TodoForm.tsx"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'import React, { KeyboardEvent } from "react";\nimport { view, Observe, Update, producer, Get } from "@c11/engine.macro";\nimport { TodoItem, TodoStatuses, TodoModes } from "./types";\n\nenum NewTodoItents {\n  commit = "commit",\n  discard = "discard"\n}\n\nconst TodoForm: view = ({\n  updateNewTodoTitle = Update.newTodo.title,\n  newTodoTitle = Observe.newTodo.title,\n  updateNewTodoIntent = Update.newTodo.intent\n}) => {\n  const keyDownToIntent = (e: KeyboardEvent) => {\n    if (e.key === "Enter") {\n      updateNewTodoIntent.set(NewTodoItents.commit);\n    }\n\n    if (e.key === "Escape") {\n      updateNewTodoIntent.set(NewTodoItents.discard);\n    }\n  };\n\n  return (\n    <input\n      className="new-todo"\n      placeholder="What needs to be done?"\n      autoFocus={true}\n      value={newTodoTitle || ""}\n      onChange={e => updateNewTodoTitle.set(e.currentTarget.value)}\n      onKeyDown={keyDownToIntent}\n    />\n  );\n};\n')),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"view"),"s can contain as much logic as required to provide a clean API. A view's\nAPI is made up of two things:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Its input: props and global state"),Object(i.b)("li",{parentName:"ol"},"Its output: JSX and global state")),Object(i.b)("p",null,"A good API do not reveal its implementation details. State shouldn't need to\nknow which key is getting pressed, but only what is the objective that a view\nwant to accomplish. To provide a clean API, an event listener can be created in\nthe view itself, which stores the intent of the TodoForm component in state in\n",Object(i.b)("inlineCode",{parentName:"p"},".newTodo.intent"),"."),Object(i.b)("p",null,"Using state as a communication mechanism between components and producers allows\nkeeping the views free of all business logic, which is kept in small producers\nwhich do one thing well. ",Object(i.b)("inlineCode",{parentName:"p"},"addNewTodo")," is going to be one such producer. Make\nthese changes in ",Object(i.b)("inlineCode",{parentName:"p"},"src/TodoForm.tsx")," to create a new producer:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),"const addNewTodo: producer = ({\n  newTodoIntent = Observe.newTodo.intent,\n  getTitle = Get.newTodo.title,\n  updateTodosById = Update.todosById,\n  updateNewTodoTitle = Update.newTodo.title\n}) => {\n  if (newTodoIntent !== NewTodoItents.commit) {\n    return;\n  }\n\n  const id = String(new Date().getTime());\n  const newTodo: TodoItem = {\n    id,\n    title: getTitle(),\n    status: TodoStatuses.pending,\n    mode: TodoModes.viewing\n  };\n\n  updateTodosById.merge({\n    [id]: newTodo\n  });\n  updateNewTodoTitle.set(null);\n};\n")),Object(i.b)("p",null,"And add it to the list of ",Object(i.b)("inlineCode",{parentName:"p"},"TodoForm"),"'s producers:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),"+ (TodoForm as any).producers = [addNewTodo];\n\nexport default TodoForm;\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"addNewTodo")," producer is doing a couple of interesting things:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"It uses ",Object(i.b)("inlineCode",{parentName:"p"},"Get.newTodo.title")," instead of ",Object(i.b)("inlineCode",{parentName:"p"},"Observe.newTodo.title"),".\n",Object(i.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/api/get"}),"Get")," is another macro, which provides a function to get live\nvalue from the state. It is very useful when our producer is doing something\nasynchronous and needs a value from state at a later time. Or as is the case\nnow, it allow accessing a value without ",Object(i.b)("inlineCode",{parentName:"p"},"Observe"),"ing it."),Object(i.b)("p",{parentName:"li"},"A ",Object(i.b)("inlineCode",{parentName:"p"},"producer")," or ",Object(i.b)("inlineCode",{parentName:"p"},"view")," gets triggered every time anything it ",Object(i.b)("inlineCode",{parentName:"p"},"Observe"),"\nchanges. ",Object(i.b)("inlineCode",{parentName:"p"},"addNewTodo")," producer should not get called whenever ",Object(i.b)("inlineCode",{parentName:"p"},"newTodo.title"),"\nchanges. It is only interested in changes in ",Object(i.b)("inlineCode",{parentName:"p"},"newTodoIntent"))),Object(i.b)("li",{parentName:"ol"},Object(i.b)("p",{parentName:"li"},"Notice that a guard has been added in starting of the producer, which checks\nif state is valid for execution of this producer. This is a common pattern in\nEngine apps, since it recommends creating small, single-responsibility\nproducers. The guard checks if the intent of newTodo is to commit it, if it\nisn't, this producer should not do anything."))),Object(i.b)("p",null,"In the spirit of single-responsibility producers, another producer can be\ncreated to cancel adding a new todo if user presses Escape key."),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),"const cancelAddingTodo: producer = ({\n  newTodoIntent = Observe.newTodo.intent,\n  updateNewTodoTitle = Update.newTodo.title\n}) => {\n  if (newTodoIntent !== NewTodoItents.discard) {\n    return;\n  }\n\n  updateNewTodoTitle.set(null);\n};\n")),Object(i.b)("p",null,"Notice it has a guard similar to ",Object(i.b)("inlineCode",{parentName:"p"},"addNewTodo"),"."),Object(i.b)("p",null,"Adding it to ",Object(i.b)("inlineCode",{parentName:"p"},"TodoForm.producers")," will bring it to life:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),"- (TodoForm as any).producers = [addNewTodo];\n+ (TodoForm as any).producers = [addNewTodo, cancelAddingTodo];\n")),Object(i.b)("p",null,'Although new todos are getting added to the state, and "Pending count" in footer\nincreases on adding new todos, new todos are not shown in the todo list.\n',Object(i.b)("inlineCode",{parentName:"p"},"visibleTodoIds")," in the state need to be kept in sync with changes in\n",Object(i.b)("inlineCode",{parentName:"p"},"todosById"),". It is in charge of which todos are visible in the list. Question\nis, where do the producer for updating ",Object(i.b)("inlineCode",{parentName:"p"},"visibleTodoIds")," belong? Should a\nproducer be added in ",Object(i.b)("inlineCode",{parentName:"p"},"TodoForm"),", which adds the todos, or should it go in ",Object(i.b)("inlineCode",{parentName:"p"},"App"),",\nwhich shows the list of todos?"),Object(i.b)("p",null,"Engine recommends that ",Object(i.b)("strong",{parentName:"p"},"views which consume the derived state should track\nit"),". Add a producer in ",Object(i.b)("inlineCode",{parentName:"p"},"src/App.tsx"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),"const syncVisibleTodoIds: producer = ({\n  todosById = Observe.todosById,\n  filter = Observe.filter,\n  visibleTodoIds = Update.visibleTodoIds\n}) => {\n  const todoIdsToDisplay = Object.entries(todosById)\n    .map(([key, value]) => {\n      switch (filter as TodoFilters) {\n        case TodoFilters.completed:\n          return value.status === TodoStatuses.done ? key : null;\n        case TodoFilters.pending:\n          return value.status === TodoStatuses.done ? null : key;\n        default:\n          return key;\n      }\n    })\n    .filter(Boolean);\n\n  visibleTodoIds.set(todoIdsToDisplay);\n};\n")),Object(i.b)("p",null,"This view is doing a bit more than just adding all the ",Object(i.b)("inlineCode",{parentName:"p"},"id"),"s from ",Object(i.b)("inlineCode",{parentName:"p"},"todosById"),".\nIt also accounts for existence of a ",Object(i.b)("inlineCode",{parentName:"p"},"filter")," in state, which don't yet exist in\nstate. This is how ",Object(i.b)("strong",{parentName:"p"},"Engine help gradually evolving the state as application\nevolves"),'. The filter will be set later, when user clicks on "All", "Active" and\n"Completed" buttons in the ',Object(i.b)("inlineCode",{parentName:"p"},"Footer"),". But before that, add this producer to\n",Object(i.b)("inlineCode",{parentName:"p"},"App"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),"(App as any).producers = [syncVisibleTodoIds];\n\nexport default App;\n")),Object(i.b)("p",null,"Before adding filters to state, let's create an enum to represent all the\npossible filters. In ",Object(i.b)("inlineCode",{parentName:"p"},"src/types.tsx"),", add:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),'export enum TodoFilters {\n  all = "all",\n  completed = "completed",\n  pending = "pending"\n}\n')),Object(i.b)("p",null,"Making a very simply change to ",Object(i.b)("inlineCode",{parentName:"p"},"src/Footer.tsx")," allows setting filters for\nvisible todos:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'- import { TodoItem, TodoStatuses } from "./types";\n+ import { TodoItem, TodoStatuses, TodoFilters } from "./types";\n\nconst Footer: view = ({\n  pendingCount = Observe.pendingCount,\n+ filter = Observe.filter,\n+ updateFilter = Update.filter\n}) => (\n...\n      <ul className="filters">\n        <li>\n-         <a href="#/" className="selected">All</a>\n+         <a\n+           href="#/"\n+           className={filter === TodoFilters.all ? "selected" : ""}\n+           onClick={() => updateFilter.set(TodoFilters.all)}\n+         >\n+          All\n+         </a>\n        </li>\n        <li>\n-         <a href="#/active">Active</a>\n+         <a\n+           href="#/active"\n+           className={filter === TodoFilters.pending ? "selected" : ""}\n+           onClick={() => updateFilter.set(TodoFilters.pending)}\n+         >\n+           Active\n+         </a>\n        </li>\n        <li>\n-         <a href="#/completed">Completed</a>\n+         <a\n+           href="#/completed"\n+           className={filter === TodoFilters.completed ? "selected" : ""}\n+           onClick={() => updateFilter.set(TodoFilters.completed)}\n+         >\n+           Completed\n+         </a>\n        </li>\n      </ul>\n')),Object(i.b)("p",null,"It's also possible to set an initial filter by setting it in the initial state.\nIn ",Object(i.b)("inlineCode",{parentName:"p"},"src/index.tsx"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'+ import { TodoFilters } from "./types";\n...\n  state: {\n    initial: {\n+     filter: TodoFilters.all,\n      todosById: {\n')))}c.isMDXComponent=!0},99:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var o=n(0),a=n.n(o);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),c=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,l=d(e,["components","mdxType","originalType","parentName"]),p=c(n),u=o,m=p["".concat(r,".").concat(u)]||p[u]||b[u]||i;return n?a.a.createElement(m,s(s({ref:t},l),{},{components:n})):a.a.createElement(m,s({ref:t},l))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var l=2;l<i;l++)r[l]=n[l];return a.a.createElement.apply(null,r)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);