(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{74:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return d})),n.d(t,"default",(function(){return c}));var o=n(2),a=n(6),i=(n(0),n(88)),r={id:"state-as-communication-channel",title:"State as Communication Channel",sidebar_label:"State as Communication Channel"},l={unversionedId:"quick-start-tutorial/state-as-communication-channel",id:"quick-start-tutorial/state-as-communication-channel",isDocsHomePage:!1,title:"State as Communication Channel",description:"We'll now make it possible to add new TodoItems to our state. To start off,",source:"@site/docs/quick-start-tutorial/state-as-communication-channel.md",permalink:"/engine/docs/quick-start-tutorial/state-as-communication-channel",editUrl:"https://github.com/code11/engine/edit/master/docs/docs/quick-start-tutorial/state-as-communication-channel.md",sidebar_label:"State as Communication Channel",sidebar:"docs",previous:{title:"Introducing Producers",permalink:"/engine/docs/quick-start-tutorial/introducing-producers"},next:{title:"Wrapping Up",permalink:"/engine/docs/quick-start-tutorial/wrapping-up"}},d=[],s={rightToc:d};function c(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(o.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"We'll now make it possible to add new ",Object(i.b)("inlineCode",{parentName:"p"},"TodoItem"),"s to our state. To start off,\nwe'll extract ",Object(i.b)("inlineCode",{parentName:"p"},"TodoForm")," component out of ",Object(i.b)("inlineCode",{parentName:"p"},"src/App.tsx"),". Create a new file\n",Object(i.b)("inlineCode",{parentName:"p"},"src/TodoForm.tsx"),", with following contents:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),'import React from "react";\n\nconst TodoForm = () => (\n  <input\n    className="new-todo"\n    placeholder="What needs to be done?"\n    autoFocus={true}\n  />\n);\n\nexport default TodoForm;\n')),Object(i.b)("p",null,"And update ",Object(i.b)("inlineCode",{parentName:"p"},"src/App.tsx")," accordingly:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'+ import TodoForm from "./TodoForm";\n...\n-    <input\n-      className="new-todo"\n-      placeholder="What needs to be done?"\n-      autoFocus={true}\n-    />\n+    <TodoForm />\n')),Object(i.b)("p",null,"Since global-state is the only kind of state recommended in Engine, we'll keep a\nstate variable for what user is typing in our ",Object(i.b)("inlineCode",{parentName:"p"},"TodoForm")," input. Update\n",Object(i.b)("inlineCode",{parentName:"p"},"src/TodoForm.tsx")," to make its content be:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),'import React from "react";\nimport { view, Observe, Update } from "@c11/engine.macro";\n\nconst TodoForm: view = ({\n  updateNewTodoTitle = Update.newTodo.title,\n  newTodoTitle = Observe.newTodo.title\n}) => (\n    <input\n      className="new-todo"\n      placeholder="What needs to be done?"\n      autoFocus={true}\n      value={newTodoTitle || ""}\n      onChange={e => updateNewTodoTitle.set(e.currentTarget.value)}\n    />\n  );\n\nexport default TodoForm;\n')),Object(i.b)("p",null,"We have,"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Labeled our ",Object(i.b)("inlineCode",{parentName:"li"},"TodoForm")," as ",Object(i.b)("inlineCode",{parentName:"li"},"view"),", so that we can use\n",Object(i.b)("a",Object(o.a)({parentName:"li"},{href:"/docs/api/observe"}),"Observe")," and ",Object(i.b)("a",Object(o.a)({parentName:"li"},{href:"/docs/api/update"}),"Update")," in it"),Object(i.b)("li",{parentName:"ol"},"Introduced a new state path ",Object(i.b)("inlineCode",{parentName:"li"},".newTodo.title")),Object(i.b)("li",{parentName:"ol"},"Update ",Object(i.b)("inlineCode",{parentName:"li"},"newTodo.title")," whenever user enters something in the ",Object(i.b)("inlineCode",{parentName:"li"},"<input>"))),Object(i.b)("p",null,"We want to add a new todo to our ",Object(i.b)("inlineCode",{parentName:"p"},"todosById")," list whenever user presses ",Object(i.b)("inlineCode",{parentName:"p"},"Enter"),"\nkey in the input. We could create an event handler in the view itself which does\nthis work, but Engine recommends we rather not. Only logic that should go into a\nview is converting event payloads into value they contain, and store them at\nsome path in state."),Object(i.b)("p",null,"We'll now"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Add event listener for ",Object(i.b)("inlineCode",{parentName:"li"},"onKeyDown")," in the input"),Object(i.b)("li",{parentName:"ol"},"Convert the pressed key to the intent TodoForm want to express, and store it\nin our state"),Object(i.b)("li",{parentName:"ol"},"Create producers for committing and discarding the new todo")),Object(i.b)("p",null,"In ",Object(i.b)("inlineCode",{parentName:"p"},"src/TodoForm.tsx"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'import React, { KeyboardEvent } from "react";\nimport { view, Observe, Update, producer, Get } from "@c11/engine.macro";\nimport { TodoItem, TodoStatuses, TodoModes } from "./types";\n\nconst TodoForm: view = ({\n  updateNewTodoTitle = Update.newTodo.title,\n  newTodoTitle = Observe.newTodo.title,\n  updateNewTodoIntent = Update.newTodo.intent\n}) => {\n  const keyDownToIntent = (e: KeyboardEvent) => {\n    if (e.key === "Enter") {\n      updateNewTodoIntent.set("commit");\n    }\n\n    if (e.key === "Escape") {\n      updateNewTodoIntent.set("discard");\n    }\n  };\n\n  return (\n    <input\n      className="new-todo"\n      placeholder="What needs to be done?"\n      autoFocus={true}\n      value={newTodoTitle || ""}\n      onChange={e => updateNewTodoTitle.set(e.currentTarget.value)}\n      onKeyDown={keyDownToIntent}\n    />\n  );\n};\n')),Object(i.b)("p",null,"Remember we said our views are dumb as bricks? Well they are, but they can also\ncontain as much logic as required to provide a clean API. A component's API\nconstitutes two things:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Input: props and global state"),Object(i.b)("li",{parentName:"ol"},"Outputs: JSX and global state")),Object(i.b)("p",null,"A good API do not reveal its implementation details. Our state shouldn't need to\nknow which key is getting pressed, but only what is the objective that our\ncomponent want to accomplish. To provide a clean API, we've added an event\nhandler in the view itself, which stores the intent of the TodoForm component in\nstate in ",Object(i.b)("inlineCode",{parentName:"p"},".newTodo.intent"),"."),Object(i.b)("p",null,"Using state as a communication mechanism between components and producers allow\nus to keep our views free of all business logic. We get to create small\nproducers which do one thing well. ",Object(i.b)("inlineCode",{parentName:"p"},"addNewTodo")," is going to be one such producer\nfor us. Make these changes in ",Object(i.b)("inlineCode",{parentName:"p"},"src/TodoForm.tsx"),", we'll add a new producer:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),'const addNewTodo: producer = ({\n  newTodoIntent = Observe.newTodo.intent,\n  getTitle = Get.newTodo.title,\n  updateTodosById = Update.todosById,\n  updateNewTodoTitle = Update.newTodo.title\n}) => {\n  if (newTodoIntent !== "commit") {\n    return;\n  }\n\n  const id = String(new Date().getTime());\n  const newTodo: TodoItem = {\n    id,\n    title: getTitle(),\n    status: TodoStatuses.pending,\n    mode: TodoModes.viewing\n  };\n\n  updateTodosById.merge({\n    [id]: newTodo\n  });\n  updateNewTodoTitle.set(null);\n};\n')),Object(i.b)("p",null,"And add it to the list of ",Object(i.b)("inlineCode",{parentName:"p"},"TodoForm"),"'s producers:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),"+ (TodoForm as any).producers = [addNewTodo];\n\nexport default TodoForm;\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"addNewTodo")," producer is doing a couple of interesting things:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"We use ",Object(i.b)("inlineCode",{parentName:"li"},"Get.newTodo.title")," instead of ",Object(i.b)("inlineCode",{parentName:"li"},"Observe.newTodo.title"),".\n",Object(i.b)("a",Object(o.a)({parentName:"li"},{href:"/docs/api/get"}),"Get")," is another macro, which provides a function to get live\nvalue from the state. It is very useful when our producer is doing something\nasynchronous and needs a value from state at a later time. Or as is the case\nnow, it allow us to access a value without ",Object(i.b)("inlineCode",{parentName:"li"},"Observe"),"ing it. A ",Object(i.b)("inlineCode",{parentName:"li"},"producer")," or\n",Object(i.b)("inlineCode",{parentName:"li"},"view")," gets triggered every time anything it ",Object(i.b)("inlineCode",{parentName:"li"},"Observe")," changes. We don't want\n",Object(i.b)("inlineCode",{parentName:"li"},"addNewTodo")," producer to get called whenever ",Object(i.b)("inlineCode",{parentName:"li"},"newTodo.title")," changes, we are\nonly interested in changes in ",Object(i.b)("inlineCode",{parentName:"li"},"pressedTodoFormKey")),Object(i.b)("li",{parentName:"ol"},"We added a guard in starting of the producer, which checks if state is valid\nfor execution of this producer. This is a common pattern in Engine apps,\nsince it recommends creating small, single-responsibility producers. Here we\ncheck if the key user has pressed is the ",Object(i.b)("inlineCode",{parentName:"li"},"Enter")," key, if it isn't, we don't\nwant to do anything in this producer.")),Object(i.b)("p",null,"In the spirit of single-responsibility producers, let's add another producer to\ncancel adding a new todo if user presses Escape key."),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),'const cancelAddingTodo: producer = ({\n  newTodoIntent = Observe.newTodo.intent,\n  updateNewTodoTitle = Update.newTodo.title\n}) => {\n  if (newTodoIntent !== "discard") {\n    return;\n  }\n\n  updateNewTodoTitle.set(null);\n};\n')),Object(i.b)("p",null,"Notice it has a guard similar to ",Object(i.b)("inlineCode",{parentName:"p"},"addNewTodo"),"."),Object(i.b)("p",null,"Adding it to ",Object(i.b)("inlineCode",{parentName:"p"},"TodoForm.producers")," will bring it to life:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),"- (TodoForm as any).producers = [addNewTodo];\n+ (TodoForm as any).producers = [addNewTodo, cancelAddingTodo];\n")),Object(i.b)("p",null,'Although we can add new todos to our state, we can see the "Pending count"\nincrease in footer on adding new todos, but we still can\'t see them added to the\nlist. We have to update ',Object(i.b)("inlineCode",{parentName:"p"},"visibleTodoIds")," in our state, which is in charge of\nwhich todos are visible in the list. Question is, where do the producer for\nupdating ",Object(i.b)("inlineCode",{parentName:"p"},"visibleTodoIds")," belong? Should we add a producer in ",Object(i.b)("inlineCode",{parentName:"p"},"TodoForm")," which\nadds the todos, or should it go in ",Object(i.b)("inlineCode",{parentName:"p"},"App"),", which shows the list of todos?"),Object(i.b)("p",null,"Engine recommends that ",Object(i.b)("strong",{parentName:"p"},"Views which consume the derived state should track\nit"),". Let's add a producer in ",Object(i.b)("inlineCode",{parentName:"p"},"src/App.tsx"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),"const syncVisibleTodoIds: producer = ({\n  todosById = Observe.todosById,\n  filter = Observe.filter,\n  visibleTodoIds = Update.visibleTodoIds\n}) => {\n  const todoIdsToDisplay = Object.entries(todosById)\n    .map(([key, value]) => {\n      switch (filter as TodoFilters) {\n        case TodoFilters.completed:\n          return value.status === TodoStatuses.done ? key : null;\n        case TodoFilters.pending:\n          return value.status === TodoStatuses.done ? null : key;\n        default:\n          return key;\n      }\n    })\n    .filter(Boolean);\n\n  visibleTodoIds.set(todoIdsToDisplay);\n};\n")),Object(i.b)("p",null,"This view is doing a bit more than just adding all the ",Object(i.b)("inlineCode",{parentName:"p"},"id"),"s from ",Object(i.b)("inlineCode",{parentName:"p"},"todosById"),".\nIt also accounts for existence of a ",Object(i.b)("inlineCode",{parentName:"p"},"filter")," in state, which don't yet exist in\nstate. This is how ",Object(i.b)("strong",{parentName:"p"},"Engine help gradually evolving the state as application\nevolves"),'. We\'ll set the filter when user clicks on "All", "Active" and\n"Completed" buttons in the ',Object(i.b)("inlineCode",{parentName:"p"},"Footer"),". But before that, let's add this producer to\nour ",Object(i.b)("inlineCode",{parentName:"p"},"App"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),"(App as any).producers = [syncVisibleTodoIds];\n\nexport default App;\n")),Object(i.b)("p",null,"Before we add filters to state, let's create an enum to represent all the\npossible filters that our app can have. In ",Object(i.b)("inlineCode",{parentName:"p"},"src/types.tsx"),", add:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),'export enum TodoFilters {\n  all = "all",\n  completed = "completed",\n  pending = "pending"\n}\n')),Object(i.b)("p",null,"Making a very simply change to ",Object(i.b)("inlineCode",{parentName:"p"},"src/Footer.tsx")," allow us to set filters for\nvisible todos:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'- import { TodoItem, TodoStatuses } from "./types";\n+ import { TodoItem, TodoStatuses, TodoFilters } from "./types";\n\nconst Footer: view = ({\n  pendingCount = Observe.pendingCount,\n+ filter = Observe.filter,\n+ updateFilter = Update.filter\n}) => (\n...\n      <ul className="filters">\n        <li>\n-         <a href="#/" className="selected">All</a>\n+         <a\n+           href="#/"\n+           className={filter === TodoFilters.all ? "selected" : ""}\n+           onClick={() => updateFilter.set(TodoFilters.all)}\n+         >\n+          All\n+         </a>\n        </li>\n        <li>\n-         <a href="#/active">Active</a>\n+         <a\n+           href="#/active"\n+           className={filter === TodoFilters.pending ? "selected" : ""}\n+           onClick={() => updateFilter.set(TodoFilters.pending)}\n+         >\n+           Active\n+         </a>\n        </li>\n        <li>\n-         <a href="#/completed">Completed</a>\n+         <a\n+           href="#/completed"\n+           className={filter === TodoFilters.completed ? "selected" : ""}\n+           onClick={() => updateFilter.set(TodoFilters.completed)}\n+         >\n+           Completed\n+         </a>\n        </li>\n      </ul>\n')),Object(i.b)("p",null,"We can also set an initial filter by setting it in our initial state in ",Object(i.b)("inlineCode",{parentName:"p"},"src/index.tsx"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'+ import { TodoFilters } from "./types";\n...\n  state: {\n    initial: {\n+     filter: TodoFilters.all,\n      todosById: {\n')))}c.isMDXComponent=!0},88:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var o=n(0),a=n.n(o);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),c=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),p=c(n),u=o,m=p["".concat(r,".").concat(u)]||p[u]||b[u]||i;return n?a.a.createElement(m,l(l({ref:t},s),{},{components:n})):a.a.createElement(m,l({ref:t},s))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var s=2;s<i;s++)r[s]=n[s];return a.a.createElement.apply(null,r)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);