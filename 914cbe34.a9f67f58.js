(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{73:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return l}));var r=n(2),a=n(6),o=(n(0),n(91)),c={id:"producer",title:"Producer",sidebar_label:"Producer"},i={unversionedId:"api/producer",id:"api/producer",isDocsHomePage:!1,title:"Producer",description:"`ts",source:"@site/docs/api/producer.md",permalink:"/engine/docs/api/producer",editUrl:"https://github.com/code11/engine/edit/master/docs/docs/api/producer.md",sidebar_label:"Producer",sidebar:"docs",previous:{title:"Engine",permalink:"/engine/docs/api/engine"},next:{title:"View",permalink:"/engine/docs/api/view"}},s=[{value:"Overview",id:"overview",children:[]},{value:"Running a producer",id:"running-a-producer",children:[]},{value:"Other ideas:",id:"other-ideas",children:[]},{value:"Parts",id:"parts",children:[{value:"Header",id:"header",children:[]},{value:"Guards",id:"guards",children:[]},{value:"Processing",id:"processing",children:[]},{value:"Effects",id:"effects",children:[]},{value:"Updates",id:"updates",children:[]}]},{value:"Example",id:"example",children:[]},{value:"Best practices",id:"best-practices",children:[]},{value:"Instance",id:"instance",children:[]}],p={rightToc:s};function l(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),'import { Producer } from "@c11/engine.macro"\n')),Object(o.b)("h2",{id:"overview"},"Overview"),Object(o.b)("p",null,"A ",Object(o.b)("inlineCode",{parentName:"p"},"Producer")," is a function that reacts to specific state changes and produces new data through specific state updates. It can also produce effects. "),Object(o.b)("p",null,"The syntax is straight forward:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"const producer: Producer = ({ /* declarations */ }) => { /* execution */ }\n")),Object(o.b)("p",null,"The ",Object(o.b)("strong",{parentName:"p"},"declarations")," is a regular object that uses the Engine API to declare what data the producer needs at runtime."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{}),"{\n  bar = Observe.foo.bar,\n  baz = Get.foo.baz\n}\n")),Object(o.b)("p",null,"The ",Object(o.b)("strong",{parentName:"p"},"execution")," part is left entirely to the developer."),Object(o.b)("p",null,"Diagram (not working for some reason):\n",Object(o.b)("img",Object(r.a)({parentName:"p"},{src:"/img/producer.jpg",alt:"Producer"}))),Object(o.b)("h2",{id:"running-a-producer"},"Running a producer"),Object(o.b)("p",null,"A ",Object(o.b)("inlineCode",{parentName:"p"},"producer")," can not be called directly. ",Object(o.b)("inlineCode",{parentName:"p"},"producer"),"s are only ever executed by\nEngine when they meet following 2 conditions:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"A ",Object(o.b)("inlineCode",{parentName:"p"},"producer")," must be added to a ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/api/view"}),"view"),"'s ",Object(o.b)("inlineCode",{parentName:"p"},".producers")," array,\nor in ",Object(o.b)("inlineCode",{parentName:"p"},"Engine"),"'s global producers list. e.g ",Object(o.b)("inlineCode",{parentName:"p"},"myProducer")," can added to the\n",Object(o.b)("inlineCode",{parentName:"p"},"Button")," view with:"),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-tsx"}),"Button.producers = [myProducer];\n"))),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"A ",Object(o.b)("inlineCode",{parentName:"p"},"producer")," must have at least one trigger. Using\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/api/observe"}),"Observe")," is the only way to add a trigger to a\n",Object(o.b)("inlineCode",{parentName:"p"},"producer"),". Whenever an ",Object(o.b)("inlineCode",{parentName:"p"},"Observe"),"d value is changed (e.g using\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/api/update"}),"Update"),"), the ",Object(o.b)("inlineCode",{parentName:"p"},"producer")," is re-executed.\n!!! Not necessarily, you can also create an empty producer that will be called when the Engine boots but it won't receive any argument."))),Object(o.b)("h2",{id:"other-ideas"},"Other ideas:"),Object(o.b)("p",null,"Producers are managed entirely by the Engine which will instantiate, trigger and remove them."),Object(o.b)("p",null,"Producers should handle a very specific task. The more specific, the better."),Object(o.b)("p",null,"Producers cannot be composed or inherited or operated in any way."),Object(o.b)("p",null,"Each producer lives in complete isolation from other producers. The only way producers can communicate is through state changes."),Object(o.b)("p",null,"The developer will not be able to decide when a producer will be executed."),Object(o.b)("p",null,"Any logic regarding the reason that a producer shouldn't be executed will exist in the ",Object(o.b)("inlineCode",{parentName:"p"},"Guards")," section (see bellow)"),Object(o.b)("p",null,"When producers need to share references (to streams, xhr requests, dom nodes, etc) they need to use the state for this sharing."),Object(o.b)("h2",{id:"parts"},"Parts"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Producer")," is build up from from one or more parts with different/specific responsabilities:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Header"),Object(o.b)("li",{parentName:"ul"},"Guards"),Object(o.b)("li",{parentName:"ul"},"Processing"),Object(o.b)("li",{parentName:"ul"},"Effects"),Object(o.b)("li",{parentName:"ul"},"Updates")),Object(o.b)("h3",{id:"header"},"Header"),Object(o.b)("p",null,"This is where you declare everything that the producer will need in the execution part."),Object(o.b)("p",null,"It can take static data, variables, parent properties, path operations, argument references."),Object(o.b)("p",null,"Any function can become a producer by labeling it with ",Object(o.b)("inlineCode",{parentName:"p"},"producer"),". It allows using Engine features to interact with\nthe state using ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/api/observe"}),"Observe"),", ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/api/get"}),"Get"),", and\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/api/update"}),"Update"),"."),Object(o.b)("p",null,"Full example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"const foo = 123\nconst producer: Producer = ({\n  varValue = foo,\n  staticValue = 'sample text',\n  propValue = Prop.value,\n  propValue2, // Same as Prop.propValue2\n  updateValue = Update.sample.path,\n  observeValue = Observe.sample.value,\n  getValue = Get.sample.otherValue,\n  refValue = Arg.propValue2\n}) => { ... }\n")),Object(o.b)("p",null,"Producers should be pure functions and any service used should be passed in the header."),Object(o.b)("p",null,"The following is encuraged to increase the testability and reusability of the producer:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"import axios from 'axios'\n\nconst producer: Producer = ({\n  get = axios.get,\n  data = Observe.data\n  ...\n}) => {\n  get({ ... })\n}\n")),Object(o.b)("h3",{id:"guards"},"Guards"),Object(o.b)("p",null,"Producers will be triggered by the Engine with both valid and invalid data."),Object(o.b)("p",null,"It is the producer responsability to decide if the data is suitable to its execution needs."),Object(o.b)("p",null,"Data from ",Object(o.b)("inlineCode",{parentName:"p"},"Observe")," operations should be checked first and the producer should exit (using return) fast."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"const producer: Producer = ({\n  description = Observe.description,\n  summary = Update.summary\n}) => {\n  if (!description || !isString(description) ) {\n    return\n  }\n  summary.set(description.substr(0, 20))\n}\n")),Object(o.b)("p",null,"Guards can also stop effects from happening (e.g. triggering another system):"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-ts"}),"import axios from 'axios'\nconst producer: Producer = ({\n  post = axios.post\n  trigger = Observe.submit,\n  getUrl = Get.url\n  getData = Get.data\n}) => {\n  if (!trigger) {\n    return\n  }\n\n  const data = getData())\n  const url = getUrl()\n  if (!isValid(data) || !url) {\n    return\n  }\n\n  post(url, data) // best practice is to handle then and catch\n}\n")),Object(o.b)("h3",{id:"processing"},"Processing"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Producers")," are responsibile with transforming or interpreting the data received from the state."),Object(o.b)("p",null,"Producers contain the logic of the Engine and any process will be defined as one ore more producers that process data and act upon it."),Object(o.b)("h3",{id:"effects"},"Effects"),Object(o.b)("p",null,"Producers can call other systems, interact with the environment and produces changes that are not visible in the state."),Object(o.b)("p",null,"As mentioned above, the APIs for doing these effects should be received from the ",Object(o.b)("inlineCode",{parentName:"p"},"Header")," in order to keep the producer pure."),Object(o.b)("p",null,"With outside effects, producers will be able to create new data that didn't exist before."),Object(o.b)("p",null,"For example making an XHR request to retrieve data, read the browser session storage, interact with the DOM API or set timers."),Object(o.b)("p",null,"Producers should inform the state upon the succesful completion or failure to carry out effects."),Object(o.b)("p",null,"Managing the failure of the effects should be handled in a separate producer if those failures are not recoverable."),Object(o.b)("h3",{id:"updates"},"Updates"),Object(o.b)("p",null,"The state can only be changed through the ",Object(o.b)("inlineCode",{parentName:"p"},"Update")," operation."),Object(o.b)("p",null,"This means, ",Object(o.b)("inlineCode",{parentName:"p"},"Producers")," will be pushing new data to the Engine which in turn trigger other producers to execute and in turn update the state."),Object(o.b)("h2",{id:"example"},"Example"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Observe"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Get")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Update"),' are used in the first object argument of a\nproducer function, which is referred to as the "header" of a function. In the\nheader, Engine operators can be used to interact with state. For example'),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-tsx"}),"const todoCounter: producer = ({\n  todosById: Observe.todosById,\n  updateCount = Update.count\n}) => (\n  const count = Object.keys(todosById).length;\n\n  updateCount.set(count);\n);\n")),Object(o.b)("h2",{id:"best-practices"},"Best practices"),Object(o.b)("p",null,"Engine recommends that ",Object(o.b)("inlineCode",{parentName:"p"},"producer"),"s should perform a single job. It is okay to\nhave many small producers doing one thing each."),Object(o.b)("h2",{id:"instance"},"Instance"),Object(o.b)("p",null,"For debugging pruposes only - Documentation in progress"))}l.isMDXComponent=!0},91:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return h}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=a.a.createContext({}),l=function(e){var t=a.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return a.a.createElement(p.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(n),u=r,h=d["".concat(c,".").concat(u)]||d[u]||b[u]||o;return n?a.a.createElement(h,i(i({ref:t},p),{},{components:n})):a.a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,c=new Array(o);c[0]=u;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,c[1]=i;for(var p=2;p<o;p++)c[p]=n[p];return a.a.createElement.apply(null,c)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);