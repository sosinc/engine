(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{74:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return c}));var o=n(2),a=n(6),r=(n(0),n(88)),i={id:"state-as-comm-mechanism",title:"State as Communication Channel",sidebar_label:"State as Communication Channel"},s={unversionedId:"quick-start-tutorial/state-as-comm-mechanism",id:"quick-start-tutorial/state-as-comm-mechanism",isDocsHomePage:!1,title:"State as Communication Channel",description:"We'll now make it possible to add new TodoItems to our state. To start off,",source:"@site/docs/quick-start-tutorial/state-as-communication-channel.md",permalink:"/engine/docs/quick-start-tutorial/state-as-comm-mechanism",editUrl:"https://github.com/code11/engine/edit/master/docs/docs/quick-start-tutorial/state-as-communication-channel.md",sidebar_label:"State as Communication Channel",sidebar:"docs",previous:{title:"Introducing Producers",permalink:"/engine/docs/quick-start-tutorial/introducing-producers"},next:{title:"Wrapping Up",permalink:"/engine/docs/quick-start-tutorial/wrapping-up"}},l=[],d={rightToc:l};function c(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"We'll now make it possible to add new ",Object(r.b)("inlineCode",{parentName:"p"},"TodoItem"),"s to our state. To start off,\nwe'll extract ",Object(r.b)("inlineCode",{parentName:"p"},"TodoForm")," component out of ",Object(r.b)("inlineCode",{parentName:"p"},"src/App.tsx"),". Create a new file\n",Object(r.b)("inlineCode",{parentName:"p"},"src/TodoForm.tsx"),", with following contents:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),'import React from "react";\n\nconst TodoForm = () => (\n  <input\n    className="new-todo"\n    placeholder="What needs to be done?"\n    autoFocus={true}\n  />\n);\n\nexport default TodoForm;\n')),Object(r.b)("p",null,"And update ",Object(r.b)("inlineCode",{parentName:"p"},"src/App.tsx")," accordingly:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'+ import TodoForm from "./TodoForm";\n...\n-    <input\n-      className="new-todo"\n-      placeholder="What needs to be done?"\n-      autoFocus={true}\n-    />\n+    <TodoForm />\n')),Object(r.b)("p",null,"Since global-state is the only kind of state recommended in Engine, we'll keep a\nstate variable for what user is typing in our ",Object(r.b)("inlineCode",{parentName:"p"},"TodoForm")," input. Update\n",Object(r.b)("inlineCode",{parentName:"p"},"src/TodoForm.tsx")," to make its content be:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),'import React from "react";\nimport { view, Observe, Update } from "@c11/engine.macro";\n\nconst TodoForm: view = ({\n  updateNewTodoTitle = Update.newTodoTitle,\n  newTodoTitle = Observe.newTodoTitle\n}) => (\n    <input\n      className="new-todo"\n      placeholder="What needs to be done?"\n      autoFocus={true}\n      value={newTodoTitle || ""}\n      onChange={e => updateNewTodoTitle.set(e.currentTarget.value)}\n    />\n  );\n\nexport default TodoForm;\n')),Object(r.b)("p",null,"We have,"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Labeled our ",Object(r.b)("inlineCode",{parentName:"li"},"TodoForm")," as ",Object(r.b)("inlineCode",{parentName:"li"},"view"),", so that we can use\n",Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"/docs/api/observe"}),"Observe")," and ",Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"/docs/api/update"}),"Update")," in it"),Object(r.b)("li",{parentName:"ol"},"Introduced a new state path ",Object(r.b)("inlineCode",{parentName:"li"},".newTodoTitle")),Object(r.b)("li",{parentName:"ol"},"Update ",Object(r.b)("inlineCode",{parentName:"li"},"newTodoTitle")," whenever user enters something in the ",Object(r.b)("inlineCode",{parentName:"li"},"<input>"))),Object(r.b)("p",null,"We want to add a new todo to our ",Object(r.b)("inlineCode",{parentName:"p"},"todosById")," list whenever user presses ",Object(r.b)("inlineCode",{parentName:"p"},"Enter"),"\nkey in the input. We could create an event handler in the view itself which does\nthis work, but Engine recommends we rather not. Only logic that should go into a\nview is converting event payloads into value they contain, and store them at\nsome path in state."),Object(r.b)("p",null,"We'll now add event listener for ",Object(r.b)("inlineCode",{parentName:"p"},"onKeyDown")," in the input, and store the pressed\nkey in state as ",Object(r.b)("inlineCode",{parentName:"p"},"pressedTodoFormKey"),". Make these changes in ",Object(r.b)("inlineCode",{parentName:"p"},"src/TodoForm.tsx"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'const TodoForm: view = ({\n  updateNewTodoTitle = Update.newTodoTitle,\n  newTodoTitle = Observe.newTodoTitle,\n+ updatePressedKey = Update.pressedTodoFormKey\n}) => (\n    <input\n      className="new-todo"\n      placeholder="What needs to be done?"\n      autoFocus={true}\n      value={newTodoTitle || ""}\n      onChange={e => updateNewTodoTitle.set(e.currentTarget.value)}\n+     onKeyDown={e => updatePressedKey.set(e.key)}\n    />\n  );\n')),Object(r.b)("p",null,"Using state as a communication mechanism between components and states allow us\nto keep our views free of all logic. We get to create small producers which do\none thing well. ",Object(r.b)("inlineCode",{parentName:"p"},"addNewTodo")," is going to be one such producer for us. Make these\nchanges in ",Object(r.b)("inlineCode",{parentName:"p"},"src/TodoForm.tsx"),", we'll add a new producer:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),'const addNewTodo: producer = ({\n  pressedKey = Observe.pressedTodoFormKey,\n  getTitle = Get.newTodoTitle,\n  updateTodosById = Update.todosById,\n  updateNewTodoTitle = Update.newTodoTitle\n}) => {\n  if (pressedKey !== "Enter") {\n    return;\n  }\n\n  const id = String(new Date().getTime());\n  const newTodo: TodoItem = {\n    id,\n    title: getTitle(),\n    status: TodoStatuses.pending\n  };\n\n  updateTodosById.merge({\n    [id]: newTodo\n  });\n  updateNewTodoTitle.set(null);\n};\n')),Object(r.b)("p",null,"And add it to the list of ",Object(r.b)("inlineCode",{parentName:"p"},"TodoForm"),"'s producers:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),"+ (TodoForm as any).producers = [addNewTodo];\n\nexport default TodoForm;\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"addNewTodo")," producer is doing a couple of interesting things:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"We use ",Object(r.b)("inlineCode",{parentName:"li"},"Get.newTodoTitle")," instead of ",Object(r.b)("inlineCode",{parentName:"li"},"Observe.newTodoTitle"),".\n",Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"/docs/api/get"}),"Get")," is another macro, which provides a function to get live\nvalue from the state. It is very useful when our producer is doing something\nasynchronous and needs a value from state at a later time. Or as is the case\nnow, it allow us to access a value without ",Object(r.b)("inlineCode",{parentName:"li"},"Observe"),"ing it. A ",Object(r.b)("inlineCode",{parentName:"li"},"producer")," or\n",Object(r.b)("inlineCode",{parentName:"li"},"view")," gets triggered every time anything it ",Object(r.b)("inlineCode",{parentName:"li"},"Observe")," changes. We don't want\n",Object(r.b)("inlineCode",{parentName:"li"},"addNewTodo")," producer to get called whenever ",Object(r.b)("inlineCode",{parentName:"li"},"newTodoTitle")," changes, we are\nonly interested in changes in ",Object(r.b)("inlineCode",{parentName:"li"},"pressedTodoFormKey")),Object(r.b)("li",{parentName:"ol"},"We added a guard in starting of the producer, which checks if state is valid\nfor execution of this producer. This is a common pattern in Engine apps,\nsince it recommends creating small, single-responsibility producers. Here we\ncheck if the key user has pressed is the ",Object(r.b)("inlineCode",{parentName:"li"},"Enter")," key, if it isn't, we don't\nwant to do anything in this producer.")),Object(r.b)("p",null,"In the spirit of single-responsibility producers, let's add another producer to\ncancel adding a new todo if user presses Escape key."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),'const cancelAddingTodo: producer = ({\n  pressedKey = Observe.pressedTodoFormKey,\n  updateNewTodoTitle = Update.newTodoTitle\n}) => {\n  if (pressedKey !== "Escape") {\n    return;\n  }\n\n  updateNewTodoTitle.set(null);\n};\n')),Object(r.b)("p",null,"Notice it has a guard similar to ",Object(r.b)("inlineCode",{parentName:"p"},"addNewTodo"),"."),Object(r.b)("p",null,"Adding it to ",Object(r.b)("inlineCode",{parentName:"p"},"TodoForm.producers")," will bring it to life:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),"- (TodoForm as any).producers = [addNewTodo];\n+ (TodoForm as any).producers = [addNewTodo, cancelAddingTodo];\n")),Object(r.b)("p",null,'Although we can add new todos to our state, we can see the "Pending count"\nincrease in footer on adding new todos, but we still can\'t see them added to the\nlist. We have to update ',Object(r.b)("inlineCode",{parentName:"p"},"visibleTodoIds")," in our state, which is in charge of\nwhich todos are visible in the list. Question is, where do the producer for\nupdating ",Object(r.b)("inlineCode",{parentName:"p"},"visibleTodoIds")," belong? Should we add a producer in ",Object(r.b)("inlineCode",{parentName:"p"},"TodoForm")," which\nadds the todos, or should it go in ",Object(r.b)("inlineCode",{parentName:"p"},"App"),", which shows the list of todos?"),Object(r.b)("p",null,"Engine recommends that ",Object(r.b)("strong",{parentName:"p"},"Views which consume the derived state should track\nit"),". Let's add a producer in ",Object(r.b)("inlineCode",{parentName:"p"},"src/App.tsx"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),"const syncVisibleTodoIds: producer = ({\n  todosById = Observe.todosById,\n  filter = Observe.filter,\n  visibleTodoIds = Update.visibleTodoIds\n}) => {\n  const todoIdsToDisplay = Object.entries(todosById)\n    .map(([key, value]) => {\n      switch (filter as TodoFilters) {\n        case TodoFilters.completed:\n          return value.status === TodoStatuses.done ? key : null;\n        case TodoFilters.pending:\n          return value.status === TodoStatuses.done ? null : key;\n        default:\n          return key;\n      }\n    })\n    .filter(Boolean);\n\n  visibleTodoIds.set(todoIdsToDisplay);\n};\n")),Object(r.b)("p",null,"This view is doing a bit more than just adding all the ",Object(r.b)("inlineCode",{parentName:"p"},"id"),"s from ",Object(r.b)("inlineCode",{parentName:"p"},"todosById"),".\nIt also accounts for existence of a ",Object(r.b)("inlineCode",{parentName:"p"},"filter")," in state, which don't yet exist in\nstate. This is how ",Object(r.b)("strong",{parentName:"p"},"Engine help gradually evolving the state as application\nevolves"),'. We\'ll set the filter when user clicks on "All", "Active" and\n"Completed" buttons in the ',Object(r.b)("inlineCode",{parentName:"p"},"Footer"),". But before that, let's add this producer to\nour ",Object(r.b)("inlineCode",{parentName:"p"},"App"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),"(App as any).producers = [syncVisibleTodoIds];\n\nexport default App;\n")),Object(r.b)("p",null,"Before we add filters to state, let's create an enum to represent all the\npossible filters that our app can have. In ",Object(r.b)("inlineCode",{parentName:"p"},"src/types.tsx"),", add:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),'export enum TodoFilters {\n  all = "all",\n  completed = "completed",\n  pending = "pending"\n}\n')),Object(r.b)("p",null,"Making a very simply change to ",Object(r.b)("inlineCode",{parentName:"p"},"src/Footer.tsx")," allow us to set filters for\nvisible todos:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'- import { TodoItem, TodoStatuses } from "./types";\n+ import { TodoItem, TodoStatuses, TodoFilters } from "./types";\n\nconst Footer: view = ({\n  pendingCount = Observe.pendingCount,\n+ filter = Observe.filter,\n+ updateFilter = Update.filter\n}) => (\n...\n      <ul className="filters">\n        <li>\n-         <a href="#/" className="selected">All</a>\n+         <a\n+           href="#/"\n+           className={filter === TodoFilters.all ? "selected" : ""}\n+           onClick={() => updateFilter.set(TodoFilters.all)}\n+         >\n+          All\n+         </a>\n        </li>\n        <li>\n-         <a href="#/active">Active</a>\n+         <a\n+           href="#/active"\n+           className={filter === TodoFilters.pending ? "selected" : ""}\n+           onClick={() => updateFilter.set(TodoFilters.pending)}\n+         >\n+           Active\n+         </a>\n        </li>\n        <li>\n-         <a href="#/completed">Completed</a>\n+         <a\n+           href="#/completed"\n+           className={filter === TodoFilters.completed ? "selected" : ""}\n+           onClick={() => updateFilter.set(TodoFilters.completed)}\n+         >\n+           Completed\n+         </a>\n        </li>\n      </ul>\n')),Object(r.b)("p",null,"We can also set an initial filter by setting it in our initial state in ",Object(r.b)("inlineCode",{parentName:"p"},"src/index.tsx"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'+ import { TodoFilters } from "./types";\n...\n  state: {\n    initial: {\n+     filter: TodoFilters.all,\n      todosById: {\n')))}c.isMDXComponent=!0},88:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var o=n(0),a=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=a.a.createContext({}),c=function(e){var t=a.a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.a.createElement(d.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(n),u=o,m=p["".concat(i,".").concat(u)]||p[u]||b[u]||r;return n?a.a.createElement(m,s(s({ref:t},d),{},{components:n})):a.a.createElement(m,s({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var d=2;d<r;d++)i[d]=n[d];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);