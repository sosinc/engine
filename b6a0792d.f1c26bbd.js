(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{70:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return c}));var o=n(2),a=n(6),i=(n(0),n(78)),r={id:"mature-architecture",title:"Recommended Architecture",sidebar_label:"Recommended Architecture"},s={unversionedId:"quick-start-tutorial/mature-architecture",id:"quick-start-tutorial/mature-architecture",isDocsHomePage:!1,title:"Recommended Architecture",description:"Just the power of view, Observe, and",source:"@site/docs/quick-start-tutorial/mature-architecture.md",permalink:"/engine/docs/quick-start-tutorial/mature-architecture",editUrl:"https://github.com/code11/engine/edit/master/docs/docs/quick-start-tutorial/mature-architecture.md",sidebar_label:"Recommended Architecture",sidebar:"docs",previous:{title:"Use the State Luke!",permalink:"/engine/docs/quick-start-tutorial/state"},next:{title:"Packages",permalink:"/engine/docs/packages"}},l=[{value:"Updating the Todos",id:"updating-the-todos",children:[]},{value:"Homework",id:"homework",children:[]}],d={rightToc:l};function c(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(o.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Just the power of ",Object(i.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/api/view"}),"view"),", ",Object(i.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/api/observe"}),"Observe"),", and\n",Object(i.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/api/update"}),"Update")," would be a huge productivity gain in traditional\nReact applications. But Engine has a lot more to offer. Before we dive into more\nfeatures of Engine, let's discuss our application's architecture a bit."),Object(i.b)("p",null,"Every UI is a representation of some business data. We call this critical\nbusiness data the user want to work with, ",Object(i.b)("strong",{parentName:"p"},"the essential state"),". Careful\nconsideration is needed for what the shape our state is going to be, even for\nsmaller applications like our todos app. After all, habits maketh man."),Object(i.b)("p",null,"We have kept our ",Object(i.b)("inlineCode",{parentName:"p"},"todos")," as an array in the state. It's usually a bad idea to\nuse arrays for storing critical business data (aka domain objects). What works\nbetter is to store our domain objects in some sort of indexed data structure\n(e.g ",Object(i.b)("inlineCode",{parentName:"p"},"Object"),"), so we can have instant access to any domain object using just\nits identifier. We'll see in this chapter, Engine has a unique way to very\nefficiently utilize such state."),Object(i.b)("p",null,"Domain objects represent our essential business data (e.g todos for a todos\napp). They often cross boundaries of different components of a software product,\nFor example, going from database to a backend application, to a serialized form\nfor network transfer (e.g JSON), to UIs. It is advisable to keep a consistent\nrepresentation of our domain objects across different components of our system.\nDoing so builds intuition and confidence in the system."),Object(i.b)("p",null,"Usually we would have a unique ",Object(i.b)("inlineCode",{parentName:"p"},"id")," field in our database, which can uniquely\nidentify a todo. We don't really have any identifier for our todos yet. We'll\nfake that, and add a fake ",Object(i.b)("inlineCode",{parentName:"p"},"id")," into every todo item our application creates."),Object(i.b)("p",null,"Let's start with modifying our initial state a bit. In ",Object(i.b)("inlineCode",{parentName:"p"},"src/index.tsx")),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),"  state: {\n    initial: {\n+     newTodoTitle: null,\n-     todos: [],\n+     todosById: {},\n    }\n  },\n")),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"We've changed our ",Object(i.b)("inlineCode",{parentName:"li"},"todos")," to ",Object(i.b)("inlineCode",{parentName:"li"},"todosById"),", which now contains an object, in\nwhich we'll store our todo items in ",Object(i.b)("inlineCode",{parentName:"li"},"id: TodoItem")," form."),Object(i.b)("li",{parentName:"ol"},"We have added ",Object(i.b)("inlineCode",{parentName:"li"},"newTodoTitle")," key to store state of todo item currently being\nadded. Engine don't necessitates doing this, but it's a good practice.")),Object(i.b)("p",null,"State like ",Object(i.b)("inlineCode",{parentName:"p"},"newTodoTitle")," is what is sometimes called ",Object(i.b)("strong",{parentName:"p"},"accidental state"),". It\nis data that isn't essential to the problem our software is trying to solve, but\nis needed to support our UI."),Object(i.b)("p",null,"Let's start updating ",Object(i.b)("inlineCode",{parentName:"p"},"App")," component in ",Object(i.b)("inlineCode",{parentName:"p"},"src/App.tsx")," to make up for change in\nshape of our state."),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'-const App: view = ({ todos = Observe.todos }) => {\n+const App: view = ({ todosById = Observe.todosById }) => {\n+  const todos = Object.keys(todosById).map((tid: string) => (\n+    <Todo id={tid} key={tid} />\n+  ));\n+\n   return (\n       ...\n-          <ul className="todo-list">{todos.map(Todo)}</ul>\n+          <ul className="todo-list">{todos}</ul>\n')),Object(i.b)("p",null,"Notice that we aren't passing the actual ",Object(i.b)("inlineCode",{parentName:"p"},"state.todosById.<todo>")," to ",Object(i.b)("inlineCode",{parentName:"p"},"Todo"),"\ncomponent as we were earlier. We are passing only the todo ID. ",Object(i.b)("strong",{parentName:"p"},"This is the\nrecommended way of rendering domain objects in Engine"),". We'll see why in just a\nminute, after we've updated our ",Object(i.b)("inlineCode",{parentName:"p"},"TodoForm"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),' const TodoForm: view = ({\n-  todos = Observe.todos,\n-  updateTodos = Update.todos,\n+  updateTodosById = Update.todosById,\n }) => {\n   ...\n   const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {\n     if (e.key === "Enter") {\n-      const newTodos = [\n-        ...todos,\n-        { isDone: false, title: e.currentTarget.value }\n-      ];\n-      updateTodos.set(newTodos);\n+      const id = new Date().getTime();\n+      updateTodos.merge({\n+        [id]: { id, isDone: false, title: e.currentTarget.value }\n+      });\n')),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Update.<key>.merge")," allow us to add to objects stored in our state, without\nneeding to ",Object(i.b)("inlineCode",{parentName:"p"},"Observe")," them."),Object(i.b)("p",null,"With this, we can add new todo items to our state. But how can ",Object(i.b)("inlineCode",{parentName:"p"},"Todo")," component\nrender them? Remember that just ",Object(i.b)("inlineCode",{parentName:"p"},"Todo")," gets the ",Object(i.b)("inlineCode",{parentName:"p"},"id")," of a todo item."),Object(i.b)("p",null,"Engine has a really innovative way to allow components render domain objects.\nLet's modify the ",Object(i.b)("inlineCode",{parentName:"p"},"Todo")," component to tie everything together:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'-import { view, Observe, Update } from "@c11/engine.macro";\n+import { view, Observe, Update, Prop } from "@c11/engine.macro";\n import "todomvc-app-css/index.css";\n\n-const Todo: React.FC<{ title: string }> = ({ title }, index) => (\n-  <li key={index}>\n+const Todo: view = ({ todo = Observe.todosById[Prop.id] }) => (\n+  <li>\n     <div className="view">\n       <input className="toggle" type="checkbox" />\n-      <label>{title}</label>\n+      <label>{todo.title}</label>\n       <button className="destroy" />\n     </div>\n-    <input className="edit" value={title} />\n+    <input className="edit" value={todo.id} />\n   </li>\n );\n')),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"We imported another macro named ",Object(i.b)("inlineCode",{parentName:"li"},"Prop"),". ",Object(i.b)("inlineCode",{parentName:"li"},"Prop")," allows us to refer to a\ncomponent's React props."),Object(i.b)("li",{parentName:"ol"},"We changed the type of our ",Object(i.b)("inlineCode",{parentName:"li"},"Todo")," component from ",Object(i.b)("inlineCode",{parentName:"li"},"React.FC")," to ",Object(i.b)("inlineCode",{parentName:"li"},"view"),". This\nis what allows ",Object(i.b)("inlineCode",{parentName:"li"},"Observe")," to do its magic in\n",Object(i.b)("a",Object(o.a)({parentName:"li"},{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"}),"destructured"),"\narguments"),Object(i.b)("li",{parentName:"ol"},"Instead of laying out the complete path of state element which we want to\n",Object(i.b)("inlineCode",{parentName:"li"},"Observe"),', we ask engine to "Give me the value stored in ',Object(i.b)("inlineCode",{parentName:"li"},"Prop.id")," key of\n",Object(i.b)("inlineCode",{parentName:"li"},"state.todosById"),'". By doing this, Engine gives us a live value representing\nthe todo item identified by its ',Object(i.b)("inlineCode",{parentName:"li"},"props.id"),". Any time, and only when something\nin this todo item changes, e.g its ",Object(i.b)("inlineCode",{parentName:"li"},"isDone")," status, our ",Object(i.b)("inlineCode",{parentName:"li"},"Todo")," component will\nbe re-rendered.")),Object(i.b)("p",null,"This approach has some notable advantages:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Our ",Object(i.b)("inlineCode",{parentName:"li"},"Todo")," will not need to go through unnecessary rendering whenever its\nparent is re-rendered. This is one of few problems in React land, for which,\noften the recommended solution is to use an immutable data-structure for the\nstate, and check for referential equality in something like\n",Object(i.b)("inlineCode",{parentName:"li"},"shouldComponentUpdate"),". Using ",Object(i.b)("inlineCode",{parentName:"li"},"Observe")," and ",Object(i.b)("inlineCode",{parentName:"li"},"Prop")," combo, we not only made\nour component more efficient, but we also saved ourselves from a lot\ncognitive load, and possible plumbing work."),Object(i.b)("li",{parentName:"ol"},"Our component became a lot more independent. It exposes a minimal surface to\nits parent (it asks only for ",Object(i.b)("inlineCode",{parentName:"li"},"id"),"). This saves us from a whole lot of\nplumbing that goes on in React applications. This allow us to focus our\nattention on the business aspects of our problem, instead of React aspects.")),Object(i.b)("p",null,"Prop is not the only macro which we can make a magical combination with\n",Object(i.b)("inlineCode",{parentName:"p"},"Observe"),". We can read about more such macros in ",Object(i.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/api/input-macros/prop"}),"input\nmacros")," section."),Object(i.b)("h3",{id:"updating-the-todos"},"Updating the Todos"),Object(i.b)("p",null,"Just like we saw in previous chapter, we can update any data in our state with\n",Object(i.b)("a",Object(o.a)({parentName:"p"},{href:"/docs/api/update"}),"Update"),". For example, to mark a todo as done when Done\ncheckbox is clicked, we need to just make this change:"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'- const Todo: view = ({ todo = Observe.todosById[Prop.id], updateTodo = Update.todosById[Prop.id]}) => {\n+ const Todo: view = ({ todo = Observe.todosById[Prop.id], updateTodo = Update.todosById[Prop.id]}) => {\n  return (\n    <li>\n      <div className="view">\n        <input\n          className="toggle"\n          type="checkbox"\n+           onChange={() => updateTodo.merge({ isDone: !todo.isDone })}\n        />\n')),Object(i.b)("p",null,'Similarly, to put the todo in "Editing" state, we can do'),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),"-        <label>{todo.title}</label>\n+        <label onDoubleClick={() => updateTodo.merge({ ...todo, isEditing: true })}>{todo.title}</label>\n")),Object(i.b)("h3",{id:"homework"},"Homework"),Object(i.b)("p",null,"Your homework for the day is:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Make ",Object(i.b)("inlineCode",{parentName:"li"},"Todo")," component fully functional"),Object(i.b)("li",{parentName:"ol"},"Make the footer working"),Object(i.b)("li",{parentName:"ol"},'Implement "Toggle all" feature')),Object(i.b)("p",null,"You can take a look at ",Object(i.b)("a",Object(o.a)({parentName:"p"},{href:"http://todomvc.com/examples/react/#/"}),"React implementation of\nTodoMVC")," to figure out all the\nfunctionality that need to be built."),Object(i.b)("details",null,Object(i.b)("summary",null,"Solution"),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),'import React, { KeyboardEvent, ChangeEvent } from "react";\nimport { view, Observe, Update, Prop } from "@c11/engine.macro";\nimport "todomvc-app-css/index.css";\n\nconst Todo: view = ({\n  todo = Observe.todosById[Prop.id],\n  updateTodo = Update.todosById[Prop.id]\n}) => {\n  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === "Enter") {\n      updateTodo.merge({\n        value: e.currentTarget.value,\n        isEditing: false\n      });\n    }\n\n    if (e.key === "Escape") {\n      updateTodo.merge({\n        value: e.currentTarget.value,\n        isEditing: false\n      });\n    }\n  };\n\n  return (\n    <li className={todo.isEditing ? "editing" : ""}>\n      <div className="view">\n        <input\n          className="toggle"\n          type="checkbox"\n          checked={todo.isDone}\n          onChange={() => updateTodo.merge({ isDone: !todo.isDone })}\n        />\n        <label onDoubleClick={() => updateTodo.merge({ isEditing: true })}>\n          {todo.title}\n        </label>\n        <button className="destroy" onClick={() => updateTodo.remove()} />\n      </div>\n      <input\n        className="edit"\n        value={todo.title}\n        onKeyDown={handleKeyDown}\n        onBlur={() => updateTodo.merge({ isEditing: false })}\n        onChange={e => updateTodo.merge({ title: e.currentTarget.value })}\n      />\n    </li>\n  );\n};\n\nconst TodoForm: view = ({\n  updateTodos = Update.todosById,\n  newTodoTitle = Observe.newTodoTitle,\n  updateNewTodoTitle = Update.newTodoTitle\n}) => {\n  const handleOnChange = (e: ChangeEvent<HTMLInputElement>) => {\n    updateNewTodoTitle.set(e.currentTarget.value);\n  };\n\n  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {\n    if (e.key === "Enter") {\n      const id = new Date().getTime();\n\n      updateTodos.merge({\n        [id]: { id, isDone: false, title: e.currentTarget.value }\n      });\n      updateNewTodoTitle.set("");\n    }\n\n    if (e.key === "Escape") {\n      updateNewTodoTitle.set("");\n    }\n  };\n\n  return (\n    <input\n      className="new-todo"\n      placeholder="What needs to be done?"\n      autoFocus={true}\n      onKeyDown={handleKeyDown}\n      onChange={handleOnChange}\n      value={newTodoTitle || ""}\n    />\n  );\n};\n\nconst App: view = ({\n  todosById = Observe.todosById,\n  updateTodosById = Update.todosById,\n  filter = Observe.filter,\n  updateFilter = Update.filter\n}) => {\n  const incompleteTodosCount = Object.values(todosById).reduce(\n    (accum: number, val) => ((val as any).isDone ? 0 : 1) + accum,\n    0\n  );\n\n  const todoIdsToDisplay = Object.entries(todosById)\n    .map(([key, value]) => {\n      switch (filter) {\n        case "completed":\n          return (value as any).isDone ? key : null;\n        case "active":\n          return (value as any).isDone ? null : key;\n        default:\n          return key;\n      }\n    })\n    .filter(Boolean) as Array<string>;\n\n  const handleToggleAll = () => {\n    const nextTodos = Object.values(todosById)\n      .map((todo: any) => {\n        return {\n          ...todo,\n          isDone: incompleteTodosCount !== 0\n        };\n      })\n      .reduce((accum, todo) => {\n        accum[todo.id] = todo;\n\n        return accum;\n      }, {});\n\n    updateTodosById.merge(nextTodos);\n  };\n\n  const todosJsx = todoIdsToDisplay.map((tid: string) => (\n    <Todo id={tid} key={tid} />\n  ));\n\n  return (\n    <section className="todoapp">\n      <div>\n        <header className="header">\n          <h1>todos</h1>\n        </header>\n\n        <TodoForm />\n\n        <section className="main">\n          <input\n            id="toggle-all"\n            className="toggle-all"\n            type="checkbox"\n            checked={incompleteTodosCount === 0}\n            onChange={handleToggleAll}\n          />\n          <label htmlFor="toggle-all">Mark all as complete</label>\n\n          <ul className="todo-list">{todosJsx}</ul>\n        </section>\n\n        <footer className="footer">\n          <span className="todo-count">\n            <strong>{incompleteTodosCount}</strong> items left\n          </span>\n          <ul className="filters">\n            <li>\n              <a\n                href="#/"\n                className={filter === "all" ? "selected" : ""}\n                onClick={() => updateFilter.set("all")}\n              >\n                All\n              </a>\n            </li>\n            <li>\n              <a\n                href="#/active"\n                className={filter === "active" ? "selected" : ""}\n                onClick={() => updateFilter.set("active")}\n              >\n                Active\n              </a>\n            </li>\n            <li>\n              <a\n                href="#/completed"\n                className={filter === "completed" ? "selected" : ""}\n                onClick={() => updateFilter.set("completed")}\n              >\n                Completed\n              </a>\n            </li>\n          </ul>\n          <button className="clear-completed">Clear completed</button>{" "}\n        </footer>\n      </div>\n    </section>\n  );\n};\n\nexport default App;\n'))))}c.isMDXComponent=!0},78:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var o=n(0),a=n.n(o);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=a.a.createContext({}),c=function(e){var t=a.a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.a.createElement(d.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},b=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(n),b=o,m=p["".concat(r,".").concat(b)]||p[b]||u[b]||i;return n?a.a.createElement(m,s(s({ref:t},d),{},{components:n})):a.a.createElement(m,s({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=b;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var d=2;d<i;d++)r[d]=n[d];return a.a.createElement.apply(null,r)}return a.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);